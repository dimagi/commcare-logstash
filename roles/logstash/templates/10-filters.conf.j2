##
# {{ ansible_managed }}
#

filter {
    if [type] == "nginx-timing" {
        grok {
            match => [
                "message", "\[%{HTTPDATE:http_timestamp}\] (?<cache_status>[-\w]+) %{WORD:http_method} %{DATA:request} HTTP/%{NUMBER:httpversion} %{NUMBER:status_code} %{NUMBER:request_time}"
            ]
        }
        # Add domain
        grok {
            match => { "message" => "/a/(?<domain>[0-9a-z-]+)" }
            tag_on_failure => ["_domainparsefailure"]
        }
        if "_domainparsefailure" in [tags] {
            mutate {
                add_field => { "domain" => "" }
                remove_tag => [ "_domainparsefailure" ]
            }
        }

        # Parse date
        date {
            match => [ "http_timestamp" , "dd/MMM/YYYY:HH:mm:ss Z" ]
        }
        # Parse request duration
        mutate {
            convert => { "request_time" => "float" }
        }

        # Set apdex
        if [request_time] {
            if [request_time] > 12 {
                mutate {
                    add_field => { "apdex" => 0 }
                }
            } else if [request_time] > 3 {
                mutate {
                    add_field => { "apdex" => 0.5 }
                }
            } else {
                mutate {
                    add_field => { "apdex" => 1 }
                }
            }
        }    
        mutate {
            convert => { "apdex" => "float" }
        }

        # Parse url_group
        if [request] =~ "/hq/multimedia/file/" {
            mutate {
                split => ["request", "/"]
                add_field => { "url_group" => "%{[request][4]}" }
            }
        } else if [request] =~ "/static/" or [request] =~ "favicon.ico" {
            mutate {
                add_field => { "url_group" => "static" }
            }
        } else if [request] =~ "^/a/[0-9a-z-]+" {
            mutate {
                split => ["request", "/"]
            }
            if "phone" in [request] {
                mutate {
                    add_field => { "url_group" => "%{[request][3]}/%{[request][4]}" }
                }
            } else {
                mutate {
                    add_field => { "url_group" => "%{[request][3]}" }
                }
                alter {
                    coalesce => [
                        "url_group", "%{url_group}", "other"
                    ]
                }
            }
        } else {
            mutate {
                add_field => { "url_group" => "%{request}" }
            }
        }

        # convert url groups to desired values
        alter {
            condrewrite => [
                "url_group", "CommCareAudio", "mm/audio",
                "url_group", "CommCareVideo", "mm/video",
                "url_group", "CommCareImage", "mm/image",
                "url_group", "/accounts/login/", "login"
            ]
        }

        # Cleanup
        mutate {
            remove_field => [ "request", "bytes", "httpversion", "message" ]
        }

    }
    
    if [type] == "nginx-error" {
        grok {
            match => [
                "message",  "(?<http_timestamp>\d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2}) \[%{DATA:err_severity}\] (%{NUMBER:pid:int}#%{NUMBER}: \*%{NUMBER}|\*%{NUMBER}) %{DATA:err_message}(?:, client: (?<clientip>%{IP}|%{HOSTNAME}))(?:, server: %{IPORHOST:server})(?:, request: \"%{WORD:verb} %{URIPATHPARAM:request} HTTP/%{NUMBER:httpversion}\")?(?:, upstream: \"%{DATA:upstream}\")?(?:, host: \"%{IPORHOST:host}\")?(?:, referrer: \"%{URI:referrer}\")?"
            ]
        }
         # Add domain
        grok {
            match => { "message" => "/a/(?<domain>[0-9a-z-]+)" }
            tag_on_failure => ["_domainparsefailure"]
        }
        if "_domainparsefailure" in [tags] {
            mutate {
                add_field => { "domain" => "" }
                remove_tag => [ "_domainparsefailure" ]
            }
        }

        # Parse date
        date {
            match => [ "http_timestamp" , "YYYY/MM/dd HH:mm:ss" ]
        }
        
        # Replace error message with custom message
        if [err_message] =~ "an upstream response is buffered to a temporary file" {
            mutate{
                replace => { "[err_message]" => "buffer_to_file/upstream" }
            } 
        }
        else if [err_message] =~ "a client request body is buffered to a temporary file" {
            mutate{
                replace => { "[err_message]" => "buffer_to_file/client" }
            } 
        }
        else if [err_message] =~ "failed \(111: Connection refused\) while connecting to upstream" {
            mutate{
                replace => { "[err_message]" => "connection_refused" }
            } 
        }
        else{
            mutate{
                replace => { "[err_message]" => "others" }
            } 
        }

        # Cleanup
        mutate {
            remove_field => [ "request", "bytes", "httpversion", "message", "pid", "referrer" ]
        }

    }


    if "_grokparsefailure" in [tags] {
        drop { }
    }
}
